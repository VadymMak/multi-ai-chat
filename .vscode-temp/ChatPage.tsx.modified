// src/pages/ChatPage.tsx
import React, {
  useEffect,
  useRef,
  useState,
  useCallback,
  lazy,
  Suspense,
} from "react";

print('test');

import { v4 as uuidv4 } from "uuid";
import { useModelStore, ModelProvider } from "../store/modelStore";
import { useChatStore } from "../store/chatStore";
import { useProjectStore } from "../store/projectStore";
import { useMemoryStore } from "../store/memoryStore";
import { useStreamText } from "../hooks/useStreamText";
import { useSessionCleanup } from "../hooks/useSessionCleanup";
import { useAppStore } from "../store/appStore";
import { useNetworkStatus } from "../hooks/useNetworkStatus";
import { useChatHandler } from "../hooks/useChatHandler";
import { toast } from "../store/toastStore";
import Sidebar from "../components/Sidebar/Sidebar";
import { WelcomeScreen } from "../components/Chat/WelcomeScreen";
import SettingsModal from "../components/Settings/SettingsModal";
import {
  sendAiMessage,
  sendAiToAiMessage,
  uploadFile,
  getLastSessionByRole,
  getChatHistory,
} from "../services/aiApi";
import { renderSupplementary } from "../utils/renderSupplementary";
import type { Sender } from "../types/chat";
import type { RenderKind, RenderMeta } from "../types/chat";
import { getKnownRoles } from "../constants/roles";
import { createSimplePdf } from "../utils/createPdf";

const ChatArea = lazy(() => import("../components/Chat/ChatArea"));
const InputBar = lazy(() => import("../components/Chat/InputBar"));
const HeaderControls = lazy(() => import("../components/Chat/HeaderControls"));

const knownRoles = getKnownRoles();

//Test incremental index

const wantsSummaryPdf = (s: string) =>
  /\bpdf\b/i.test(s) &&
  /\bsummary|summarise|summarize|summarization|summarisation\b/i.test(s);

const parsePdfCommand = (raw: string): string[] | null => {
  const trimmed = raw.trim();
  if (!trimmed.startsWith("/pdf")) return null;
  const body = trimmed.replace(/^\/pdf\b/, "").trim();
  if (!body) return null;
  const parts = body.includes("|") ? body.split("|") : body.split(/\r?\n/);
  return parts.map((p) => p.trim()).filter(Boolean);
};

const parseRenderOverride = (
  raw: string
): { clean: string; kind?: RenderKind } => {
  let s = raw.trimStart();
  const slash = s.match(
    /^\/(plain|md|markdown|code|poem|poem_plain|poem_code)\b\s*/i
  );
  if (slash) {
    const cmd = slash[1].toLowerCase();
    s = s.slice(slash[0].length);
    let kind: RenderKind | undefined;
    if (cmd === "plain") kind = "plain";
    else if (cmd === "md" || cmd === "markdown") kind = "markdown";
    else if (cmd === "code") kind = "code";
    else if (cmd === "poem" || cmd === "poem_plain") kind = "poem_plain";
    else if (cmd === "poem_code") kind = "poem_code";
    return { clean: s.trim(), kind };
  }
  const prefix = s.match(
    /^(plain|md|markdown|code|poem|poem_plain|poem_code)\s*:\s*/i
  );
  if (prefix) {
    const head = prefix[1].toLowerCase();
    s = s.slice(prefix[0].length);
    let kind: RenderKind | undefined;
    if (head === "plain") kind = "plain";
    else if (head === "md" || head === "markdown") kind = "markdown";
    else if (head === "code") kind = "code";
    else if (head === "poem" || head === "poem_plain") kind = "poem_plain";
    else if (head === "poem_code") kind = "poem_code";
    return { clean: s.trim(), kind };
  }
  return { clean: raw.trim() };
};

// --- simple link extraction helpers (markdown + bare) ---
const MD_LINK_RE = /\[([^\]]+)\]\((https?:\/\/[^\s)]+)\)/gi;
const BARE_URL_RE = /(https?:\/\/[^\s)]+)/gi;

function extractLinks(text: string) {
  const seen = new Set<string>();
  const items: { title: string; url: string }[] = [];
  let m: RegExpExecArray | null;

  while ((m = MD_LINK_RE.exec(text))) {
    const title = (m[1] || "").trim();
    const url = (m[2] || "").trim();
    if (url && !seen.has(url)) {
      seen.add(url);
      items.push({ title: title || url, url });
    }
  }
  while ((m = BARE_URL_RE.exec(text))) {
    const url = (m[1] || "").trim();
    if (url && !seen.has(url)) {
      seen.add(url);
      items.push({ title: url, url });
    }
  }
  return items;
}

const isYouTube = (u: string) => /(?:youtube\.com|youtu\.be)/i.test(u);

const ChatPage: React.FC = () => {
  const [input, setInput] = useState("");

  const inputWrapRef = useRef<HTMLDivElement>(null);
  const [inputHeight, setInputHeight] = useState<number>(84);

  const abortRef = useRef<AbortController | null>(null);
  const provider = useModelStore((s) => s.provider) as ModelProvider;

  const role = useMemoryStore((s) => s.role);
  const hasHydrated = useMemoryStore((s) => s.hasHydrated);
  const projectId = useProjectStore((s) => s.projectId ?? null);

  const chatSessionId = useChatStore((s) => s.chatSessionId);
  const sessionReady = useChatStore((s) => s.sessionReady);
  const addMessage = useChatStore((s) => s.addMessage);
  const setTyping = useChatStore((s) => s.setTyping);

  const streamText = useStreamText();
  const roleId = typeof role?.id === "number" ? role.id : null;
  const hasRestoredRole = useRef(false);

  // Network status
  const { isOnline } = useNetworkStatus();

  // ‚úÖ Initialize useChatHandler for code detection
  const typedProvider =
    provider === "boost"
      ? null
      : (provider as "openai" | "anthropic" | "all" | null);

  const chatHandler = useChatHandler({
    input,
    setInput,
    abortRef,
    provider,
    typedProvider,
    roleId,
    projectId: projectId ?? "",
    chatSessionId: chatSessionId ?? undefined,
    setTyping,
    addMessage,
    streamText,
    sendAiMessage,
    sendAiToAiMessage,
  });

  // State for first-time user and settings modal
  const [isFirstTimeUser, setIsFirstTimeUser] = useState(() => {
    return !localStorage.getItem("hasCreatedProject");
  });
  const [isSettingsOpen, setIsSettingsOpen] = useState(false);

  const openCreateProjectModal = () => {
    setIsSettingsOpen(true);
  };

  // Observe InputBar wrapper height (throttled via rAF)
  useEffect(() => {
    const el = inputWrapRef.current;
    if (!el || typeof ResizeObserver === "undefined") return;
    let raf: number | null = null;

    const ro = new ResizeObserver((entries) => {
      const last = entries[entries.length - 1];
      const h = Math.ceil(last.contentRect.height);
      if (raf != null) cancelAnimationFrame(raf);
      raf = requestAnimationFrame(() => {
        setInputHeight((prev) => (prev !== h ? h : prev));
      });
    });

    ro.observe(el);
    // initial measure
    try {
      const h0 = Math.ceil(el.getBoundingClientRect().height);
      setInputHeight((prev) => (prev !== h0 ? h0 : prev));
    } catch {}

    return () => {
      try {
        ro.disconnect();
      } catch {}
      if (raf != null) cancelAnimationFrame(raf);
    };
  }, []);

  // Abort any in-flight stream on unmount
  useEffect(() => {
    return () => {
      try {
        abortRef.current?.abort();
        abortRef.current = null;
      } catch {}
    };
  }, []);

  useSessionCleanup();

  // HYDRATE HISTORY once per (roleId, projectId, chatSessionId)
  useEffect(() => {
    console.log("üîç [History Effect]", {
      roleId,
      projectId,
      chatSessionId,
      sessionReady: useChatStore.getState().sessionReady,
      messagesCount: useChatStore.getState().messages.length,
    });

    const store = useChatStore.getState();
    if (!roleId || !projectId || !chatSessionId || !store.sessionReady) {
      console.log("‚è∏Ô∏è [History] Not ready yet", {
        hasRoleId: !!roleId,
        hasProjectId: !!projectId,
        hasChatSessionId: !!chatSessionId,
        sessionReady: store.sessionReady,
      });
      return;
    }

    const alreadyHas = store.messages?.some(
      (m) =>
        String(m.project_id) === String(projectId) &&
        String(m.chat_session_id) === String(chatSessionId) &&
        Number(m.role_id) === Number(roleId)
    );

    if (alreadyHas) {
      return;
    }

    (async () => {
      try {
        const { messages } = await getChatHistory(
          projectId,
          roleId,
          chatSessionId
        );

        if (messages.length) {
          useChatStore.getState().setMessages(messages);
        } else {
          console.log("‚ö†Ô∏è [History] No messages to load");
        }
      } catch (e) {
        console.error("‚ùå [History] Failed to load:", e);
      }
    })();
  }, [roleId, projectId, chatSessionId]);

  useSessionCleanup();

  const ensureSessionId = useCallback(
    async (rid: number, pid: number): Promise<string | null> => {
      let sid = useChatStore.getState().chatSessionId;
      if (sid) return sid;
      try {
        sid = await useChatStore.getState().waitForSessionReady(rid, pid, 5000);
        return sid;
      } catch (e) {
        console.warn("‚ö†Ô∏è Session not ready in time:", e);
        return null;
      }
    },
    []
  );

  // ‚¨áÔ∏è accepts overrides and prefers overrides.kind over parsed slash/prefix
  const handleSend = useCallback(
    async (
      text?: string,
      overrides?: {
        kind?: RenderKind;
        language?: string | null;
        filename?: string | null;
      },
      attachments?: File[],
      searchOptions?: {
        webSearchEnabled?: boolean;
        youtubeSearchEnabled?: boolean;
        mode?: "debate" | "project-builder"; // ‚Üê NEW
      }
    ) => {
      const raw = (text ?? input).trim();
      if (!raw || !roleId || !projectId) return;

      // Check network status before sending
      if (!isOnline) {
        toast.warning("üì° No internet connection. Please check your network.");
        return;
      }

      const { clean, kind: parsedKind } = parseRenderOverride(raw);
      const selectedKind = overrides?.kind ?? parsedKind;
      let messageToSend = clean; // –ò–ó–ú–ï–ù–ï–ù–û –Ω–∞ let –≤–º–µ—Å—Ç–æ const

      const sid =
        chatSessionId || (await ensureSessionId(roleId, Number(projectId)));
      if (!sid) {
        console.warn("‚ö†Ô∏è No chatSessionId ‚Äî cannot send message.");
        return;
      }

      // Upload attachments and collect file context
      let fileContexts: string[] = [];
      if (attachments && attachments.length > 0) {
        for (const file of attachments) {
          try {
            const result = await uploadFile(
              file,
              roleId,
              projectId,
              sid,
              provider
            );

            if (result) {
              console.log(`‚úÖ Upload result:`, result);

              // –°–æ–±–∏—Ä–∞–µ–º –∫–æ–Ω—Ç–µ–∫—Å—Ç –∏–∑ –∑–∞–≥—Ä—É–∂–µ–Ω–Ω–æ–≥–æ —Ñ–∞–π–ª–∞
              const fileContext = `
[File: ${file.name}]
${result.preview ? `Content: ${result.preview}` : ""}
${result.summary ? `Summary: ${result.summary}` : "No content extracted"}
            `.trim();

              fileContexts.push(fileContext);
            }
          } catch (err) {
            console.error(`Failed to upload ${file.name}:`, err);
          }
        }

        // –í–ê–ñ–ù–û: –î–æ–±–∞–≤–ª—è–µ–º –∫–æ–Ω—Ç–µ–∫—Å—Ç —Ñ–∞–π–ª–æ–≤ –∫ —Å–æ–æ–±—â–µ–Ω–∏—é –¥–ª—è AI
        if (fileContexts.length > 0) {
          const filesInfo = fileContexts.join("\n\n---\n\n");
          messageToSend = messageToSend
            ? `${messageToSend}\n\nFile Information:\n${filesInfo}`
            : `Please analyze these uploaded files:\n\n${filesInfo}`;

          console.log("üì§ Message with file context:", messageToSend);
        }
      }

      // PDF command mode (–æ—Å—Ç–∞–≤–ª—è–µ–º –∫–∞–∫ –µ—Å—Ç—å)
      const pdfLines = parsePdfCommand(messageToSend);
      if (pdfLines && pdfLines.length) {
        // ... —Å—É—â–µ—Å—Ç–≤—É—é—â–∏–π PDF –∫–æ–¥ –±–µ–∑ –∏–∑–º–µ–Ω–µ–Ω–∏–π ...
        setTyping(true);
        abortRef.current?.abort();
        abortRef.current = new AbortController();

        const userMessage = {
          id: `user-${uuidv4()}`,
          sender: "user" as Sender,
          text: raw,
          role_id: roleId,
          project_id: projectId,
          chat_session_id: sid,
        };
        addMessage(userMessage);
        setInput("");

        try {
          const { url, filename } = await createSimplePdf(pdfLines, {
            title: "Export",
            filename: "chat-output",
          });
          addMessage({
            id: `ai-${uuidv4()}`,
            sender: "openai",
            text: "üìÑ Here is your PDF export.",
            role_id: roleId,
            project_id: projectId,
            chat_session_id: sid,
            attachments: [
              {
                id: `att-${uuidv4()}`,
                name: filename,
                mime: "application/pdf",
                url,
              },
            ],
          });
        } catch (err) {
          console.error("‚ùå PDF creation failed:", err);
          addMessage({
            id: `ai-${uuidv4()}`,
            sender: "openai",
            text: "‚ö†Ô∏è Failed to create PDF.",
            role_id: roleId,
            project_id: projectId,
            chat_session_id: sid,
          });
        } finally {
          setTyping(false);
        }
        return;
      }

      const wantsPdf = wantsSummaryPdf(messageToSend);

      // ‚úÖ DELEGATE TO chatHandler for code detection (works for openai/anthropic/all)
      if (provider !== "boost") {
        console.log(
          "‚úÖ [Detection] Delegating to chatHandler for code detection"
        );
        try {
          await chatHandler.handleSend(
            messageToSend,
            overrides,
            attachments,
            searchOptions
          );
        } catch (error) {
          console.error("‚ùå chatHandler.handleSend failed:", error);
        }
        return;
      }

      // ‚úÖ BOOST MODE ONLY - Handle manually
      setTyping(true);
      abortRef.current?.abort();
      abortRef.current = new AbortController();

      // Add user bubble - –ø–æ–∫–∞–∑—ã–≤–∞–µ–º –æ—Ä–∏–≥–∏–Ω–∞–ª—å–Ω—ã–π —Ç–µ–∫—Å—Ç –±–µ–∑ –∫–æ–Ω—Ç–µ–∫—Å—Ç–∞ —Ñ–∞–π–ª–æ–≤
      const userMessage = {
        id: `user-${uuidv4()}`,
        sender: "user" as Sender,
        text: clean, // –í–ê–ñ–ù–û: –ø–æ–∫–∞–∑—ã–≤–∞–µ–º clean, –∞ –Ω–µ messageToSend
        role_id: roleId,
        project_id: projectId,
        chat_session_id: sid,
      };
      addMessage(userMessage);
      setInput("");

      try {
        if (provider === "boost") {
          const result = await sendAiToAiMessage(
            messageToSend,
            "openai",
            roleId,
            projectId,
            sid,
            searchOptions?.webSearchEnabled,
            searchOptions?.youtubeSearchEnabled,
            searchOptions?.mode ?? "debate" // ‚Üê NEW
          );

          // ... –æ—Å—Ç–∞–ª—å–Ω–æ–π –∫–æ–¥ boost mode –±–µ–∑ –∏–∑–º–µ–Ω–µ–Ω–∏–π ...
          let collected = "";
          let starterTextForLinks: string | null = null;

          let idx = -1;
          for (const { sender, text, isSummary } of result.messages) {
            idx++;
            const msgId = `${sender}-${uuidv4()}`;
            addMessage({
              id: msgId,
              sender: sender as Sender,
              text: "",
              isTyping: true,
              isSummary,
              role_id: roleId,
              project_id: projectId,
              chat_session_id: sid,
            });
            const chunkText = text || "‚ö†Ô∏è Empty";
            await streamText(msgId, chunkText, abortRef.current?.signal);

            if (idx === 0) starterTextForLinks = chunkText;

            const s = String(sender);
            if (s !== "web" && s !== "youtube") {
              collected += (collected ? "\n\n" : "") + chunkText;
            }
          }

          // YouTube/Web –æ–±—Ä–∞–±–æ—Ç–∫–∞ –æ—Å—Ç–∞–µ—Ç—Å—è –±–µ–∑ –∏–∑–º–µ–Ω–µ–Ω–∏–π
          if (result.youtube?.length) {
            await renderSupplementary(
              "youtube",
              result.youtube,
              addMessage,
              streamText,
              abortRef.current?.signal,
              roleId,
              projectId,
              sid
            );
          } else if (starterTextForLinks) {
            const links = extractLinks(starterTextForLinks)
              .filter((x) => isYouTube(x.url))
              .slice(0, 6);
            if (links.length) {
              await renderSupplementary(
                "youtube",
                links,
                addMessage,
                streamText,
                abortRef.current?.signal,
                roleId,
                projectId,
                sid
              );
            }
          }

          if (result.web?.length) {
            await renderSupplementary(
              "web",
              result.web,
              addMessage,
              streamText,
              abortRef.current?.signal,
              roleId,
              projectId,
              sid
            );
          } else if (starterTextForLinks) {
            const links = extractLinks(starterTextForLinks)
              .filter((x) => !isYouTube(x.url))
              .slice(0, 6);
            if (links.length) {
              await renderSupplementary(
                "web",
                links,
                addMessage,
                streamText,
                abortRef.current?.signal,
                roleId,
                projectId,
                sid
              );
            }
          }

          const returnedSid = (result as any)?.chat_session_id as
            | string
            | undefined;
          if (returnedSid) {
            useChatStore.getState().handleSessionIdUpdateFromAsk(returnedSid);
          }

          if (wantsPdf && collected.trim()) {
            try {
              const lines = collected.split(/\r?\n/).filter((l) => l.trim());
              const { url, filename } = await createSimplePdf(lines, {
                title: "Summary",
                filename: `summary-${sid.slice(0, 8)}`,
              });
              addMessage({
                id: `ai-${uuidv4()}`,
                sender: "openai",
                text: "üìÑ Summary exported as PDF.",
                role_id: roleId,
                project_id: projectId,
                chat_session_id: sid,
                attachments: [
                  {
                    id: `att-${uuidv4()}`,
                    name: filename,
                    mime: "application/pdf",
                    url,
                  },
                ],
              });
            } catch (err) {
              console.error("‚ùå PDF export failed:", err);
            }
          }
        } else {
          // /ask
          const result = await sendAiMessage(
            messageToSend, // –í–ê–ñ–ù–û: –æ—Ç–ø—Ä–∞–≤–ª—è–µ–º messageToSend —Å –∫–æ–Ω—Ç–µ–∫—Å—Ç–æ–º
            provider as "openai" | "anthropic" | "all",
            roleId,
            projectId,
            sid,
            selectedKind
              ? {
                  kind: selectedKind,
                  language:
                    overrides && "language" in overrides
                      ? overrides.language ?? undefined
                      : undefined,
                  filename:
                    overrides && "filename" in overrides
                      ? overrides.filename ?? undefined
                      : undefined,
                }
              : undefined
          );

          // ... –æ—Å—Ç–∞–ª—å–Ω–æ–π –∫–æ–¥ –æ–±—Ä–∞–±–æ—Ç–∫–∏ –æ—Ç–≤–µ—Ç–∞ –±–µ–∑ –∏–∑–º–µ–Ω–µ–Ω–∏–π ...
          if (result?.chat_session_id) {
            useChatStore
              .getState()
              .handleSessionIdUpdateFromAsk(result.chat_session_id);
          }

          if (provider === "all") {
            let collected = "";
            const topSources = (result as any)?.sources;

            for (const m of result.messages) {
              const id = `ai-${uuidv4()}`;
              const sender = (m.sender as Sender) || "openai";
              const textOut = String(m.text ?? "");
              const renderMeta = (m as any)?.render as RenderMeta | undefined;

              addMessage({
                id,
                sender,
                text: "",
                isTyping: true,
                role_id: roleId,
                project_id: projectId,
                chat_session_id: sid,
                ...(renderMeta ? ({ render: renderMeta } as any) : {}),
              });

              await streamText(
                id,
                textOut || "ü§ñ No response",
                abortRef.current?.signal
              );

              if (sender !== "web" && sender !== "youtube") {
                collected += (collected ? "\n\n" : "") + (textOut || "");
              }
            }

            if (topSources?.youtube?.length) {
              await renderSupplementary(
                "youtube",
                topSources.youtube,
                addMessage,
                streamText,
                abortRef.current?.signal,
                roleId,
                projectId,
                sid
              );
            }
            if (topSources?.web?.length) {
              await renderSupplementary(
                "web",
                topSources.web,
                addMessage,
                streamText,
                abortRef.current?.signal,
                roleId,
                projectId,
                sid
              );
            }

            if (wantsPdf && collected.trim()) {
              try {
                const lines = collected.split(/\r?\n/).filter((l) => l.trim());
                const { url, filename } = await createSimplePdf(lines, {
                  title: "Summary",
                  filename: `summary-${sid.slice(0, 8)}`,
                });
                addMessage({
                  id: `ai-${uuidv4()}`,
                  sender: "openai",
                  text: "üìÑ Summary exported as PDF.",
                  role_id: roleId,
                  project_id: projectId,
                  chat_session_id: sid,
                  attachments: [
                    {
                      id: `att-${uuidv4()}`,
                      name: filename,
                      mime: "application/pdf",
                      url,
                    },
                  ],
                });
              } catch (err) {
                console.error("‚ùå PDF export failed:", err);
              }
            }
          } else {
            // SINGLE MODEL
            const sources =
              (result as any)?.sources ??
              (result?.messages?.[0] as any)?.sources ??
              undefined;

            const renderMeta =
              ((result?.messages?.[0] as any)?.render as
                | RenderMeta
                | undefined) ?? undefined;

            const id = `ai-${uuidv4()}`;
            addMessage({
              id,
              sender: provider as Sender,
              text: "",
              isTyping: true,
              role_id: roleId,
              project_id: projectId,
              chat_session_id: sid,
              ...(renderMeta ? ({ render: renderMeta } as any) : {}),
            });

            const aiText = result.messages[0]?.text || "ü§ñ No response";
            await streamText(id, aiText, abortRef.current?.signal);

            if (sources?.youtube?.length) {
              await renderSupplementary(
                "youtube",
                sources.youtube,
                addMessage,
                streamText,
                abortRef.current?.signal,
                roleId,
                projectId,
                sid
              );
            }
            if (sources?.web?.length) {
              await renderSupplementary(
                "web",
                sources.web,
                addMessage,
                streamText,
                abortRef.current?.signal,
                roleId,
                projectId,
                sid
              );
            }

            if (wantsPdf && aiText.trim()) {
              try {
                const lines = aiText.split(/\r?\n/).filter((l) => l.trim());
                const { url, filename } = await createSimplePdf(lines, {
                  title: "Summary",
                  filename: `summary-${sid.slice(0, 8)}`,
                });
                addMessage({
                  id: `ai-${uuidv4()}`,
                  sender: "openai",
                  text: "üìÑ Summary exported as PDF.",
                  role_id: roleId,
                  project_id: projectId,
                  chat_session_id: sid,
                  attachments: [
                    {
                      id: `att-${uuidv4()}`,
                      name: filename,
                      mime: "application/pdf",
                      url,
                    },
                  ],
                });
              } catch (err) {
                console.error("‚ùå PDF export failed:", err);
              }
            }
          }
        }
      } catch (err: any) {
        console.error("‚ùå Send failed:", err);

        // Handle different error types with appropriate toasts
        if (err?.isNetworkError) {
          toast.warning(
            "üì° Network error. Please check your internet connection."
          );
        } else if (err?.isTimeout) {
          toast.warning(
            "‚è±Ô∏è Request timeout. The server is taking too long to respond."
          );
        } else if (err?.status >= 500) {
          toast.error("‚ùå Server error. Please try again later.");
        } else if (err?.message) {
          toast.error(`‚ùå ${err.message}`);
        } else {
          toast.error("‚ùå Failed to send message. Please try again.");
        }
      } finally {
        setTyping(false);
      }
    },
    [
      input,
      isOnline,
      provider,
      roleId,
      projectId,
      chatSessionId,
      addMessage,
      streamText,
      setTyping,
      ensureSessionId,
    ]
  );

  const handleKeyDown = useCallback(
    (e: React.KeyboardEvent<HTMLTextAreaElement>) => {
      if (e.key === "Enter" && !e.shiftKey) {
        e.preventDefault();
        handleSend();
      }
    },
    [handleSend]
  );

  return (
    <>
      <div className="flex flex-col h-screen overflow-hidden bg-background">
        {/* Body */}
        <div className="flex flex-1 overflow-hidden">
          {/* Sidebar */}
          <Sidebar />

          {/* Main Chat */}
          <div className="flex flex-col flex-1 min-w-0">
            {/* Header Controls - AI Selector, Balance, Projects */}
            <Suspense fallback={null}>
              <HeaderControls />
            </Suspense>
            <div className="flex-1 min-h-0">
              {sessionReady && projectId === null && isFirstTimeUser ? (
                <WelcomeScreen onCreateProject={openCreateProjectModal} />
              ) : (
                <Suspense
                  fallback={
                    <div className="p-4 text-sm text-text-secondary">
                      Loading chat‚Ä¶
                    </div>
                  }
                >
                  <ChatArea bottomPad={inputHeight} />
                </Suspense>
              )}
            </div>

            {/* InputBar - only show when there's a project */}
            {projectId !== null && (
              <div
                ref={inputWrapRef}
                className="border-t border-border p-3 bg-panel shrink-0"
              >
                <Suspense
                  fallback={
                    <div className="p-2 text-sm text-text-secondary">
                      Loading input‚Ä¶
                    </div>
                  }
                >
                  <InputBar
                    input={input}
                    setInput={setInput}
                    handleSend={handleSend}
                    handleKeyDown={handleKeyDown}
                    abortRef={abortRef}
                  />
                </Suspense>
              </div>
            )}
          </div>
        </div>

        <footer className="text-center text-xs text-text-secondary py-2 border-t border-border bg-panel">
          ¬© {new Date().getFullYear()} Your AI Assistant ‚Ä¢ Built with React +
          FastAPI
        </footer>
      </div>

      {/* Settings Modal */}
      <SettingsModal
        isOpen={isSettingsOpen}
        onClose={() => setIsSettingsOpen(false)}
        initialTab="projects"
      />
    </>
  );
};

export default ChatPage;
